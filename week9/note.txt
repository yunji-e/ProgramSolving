>>Quick Sort(퀵정렬)
    //임의의 수 기준(주로 마지막 원소)
    //좌-작은 수 & 우-큰 수 오도록 재배치
    //좌에서 & 우에서 반복
    31 8 48 73 11 3 20 29 65 15 -입력
    31|8 48 73 11 3 20 29 65 15
    8|31|48 73 11 3 20 29 65 15
    8|31 48|73 11 3 20 29 65 15
    8|31 48 73|11 3 20 29 65 15
    8 11|48 73 31|3 20 29 65 15
    8 11 3|73 31 48|20 29 65 15
    8 11 3|73 31 48 20|29 65 15
    8 11 3|73 31 48 20 29|65 15
    8 11 3|73 31 48 20 29 65|15
    8 11 3|15|73 31 48 20 29 65 -1차 완료

    quickSort(A[], p, r){
        if(p<r) {
            q = partition(A, p, r); -분할
            quickSort(A, p, q-1); -왼쪽정렬
            quickSort(A, q+1, r); -오른쪽정렬
        }
    }
    partition(A[], p, r){
        //배열 A[p...r]의 원소들을 A[r]기준으로 양쪽으로 재배치
        //A[r]의 위치 리턴
    }

>>Merge Sort(합병정렬)
    //배열을 반으로 나누기
    //각각의 배열 독립적으로 정렬
    //나눈 배열 순서 맞춰 합치기
    31 3 65 73 8 11 20 29 48 15 -입력
    31 3 65 73 8|11 20 29 48 15 -분할
    3 8 31 65 73|11 15 20 29 48 -정렬(재귀로 분할-정렬-합병 반복)
    3 8 11 15 20 29 31 48 65 73 -합병
    
    mergeSort(A[], p, r){
        if(p<r){
            q <- (p+r)/2;
            mergeSort(A, p, q);
            mergeSort(A, q+1, r);
            merge(A, p, q, r);
        }
    }
    merge(A[], p, q, r){
        //정렬된 배열A[p...q]와 A[q+1...r]을 합하여
        //정렬된 하나의 배열 A[p...r]을 만들기(별도의 배열 B[]에 )
    }
